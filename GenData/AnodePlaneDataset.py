# Class that allows a directory containing .safetensor files generated by CreateData.py to be read in by PyTorch via DataSet/DataLoader classes
# What it effectively does is assign each scatter series across all of the files some unique_id
# It then creates a map from this unique_id to the parameters needed to lazy load the input images and output data of a given scatter series

# Adapted from PyTorch Documentation found here: https://pytorch.org/tutorials/beginner/data_loading_tutorial.html
# Safetensors info: https://github.com/huggingface/safetensors

import os
import torch
from torch.utils.data import Dataset, DataLoader
from torchvision import transforms as TRANS
import matplotlib.pyplot as plt
import numpy as np
from safetensors.torch import safe_open

def extract_safetensor_paths(folder_name):
# helper function to get paths to all .safetensors files in a folder
    if not os.path.exists(folder_name):
        raise Exception("Invalid folder")
    for file in os.listdir(folder_name):
        if os.path.isfile(os.path.join(folder_name, file)):
            if file.endswith(".safetensors"):
                yield os.path.join(folder_name,file)

class AnodePlaneDataset(Dataset):
    def __init__(self,dataset_folder, verbose = False, max_files=None, 
#                 transform=None):
                 transform=TRANS.Compose([TRANS.RandomHorizontalFlip(), TRANS.RandomVerticalFlip()])):
# dataset_folder (filepath): a folder consisting entirely of .safetensor files. Need 2 seperate folders for Test and Train
# verbose (bool): print out stuff
# max_files (positive int): set a limit on the number of files to read. Used to select the first N files in a folder (say if you want to debug stuff and don't need to generate the entire mapping)
# transform (pytorch transformations): list of torchvision transformations to apply. Defaults to random flips along x/y axis
# parameters used to construct weight map
# Number of escape events, and their average energy
        self.total_escape = 0
        self.avg_energy_escape = 0
# Number of all in events, and their average energy
        self.avg_energy_all_in = 0
        self.total_all_in = 0
        self.weight_map = []
        self.transform = transform
# prefixes for tensor names in .safetensors file
        self.input_name = "input_anode_images"
        self.output_name = "output_anode_images"
# mapping between global index to relavent data to pull correct tensor (batch_filepath, input_key, output_key,  event_id)
        self.index_mapping = {}
# identifier for each event in each run in each file
        global_index = 0
# For each .safetensors file in the folder
        file_count = 0
        for fpath in extract_safetensor_paths(dataset_folder):
            file_count += 1
            if max_files:
                if(file_count > max_files):
                    break
            with safe_open(fpath, framework="pt") as f:
# Grab the names of all of the tensors stored
                key_names = [run_id for run_id in f.keys()]
# Validate that there are exactly 2 tensors
                if (len(key_names) != 2):
                    raise Exception("Uneven number of tensors. Input and Output numbers don't match")
# Making sure that the correct tensor are present in the file
                if self.input_name not in key_names:
                    raise Exception(self.input_name+" not found")
                if self.output_name not in key_names:
                    raise Exception(self.output_name+" not found")
# If you get here, we know that self.input_name and self.output_name are valid tensors within the file. Grab them
                input_data = f.get_tensor(self.input_name)
                output_data = f.get_tensor(self.output_name)
# Verify that there are the same number of events in each file
                input_data_n_events = input_data.shape[0]
                output_data_n_events = output_data.shape[0]
                if input_data_n_events != output_data_n_events:
                    raise Exception("Number of events don't match in file "+fpath)
# Add the fpath, input tensor name, output tensor name, and event number to the map, then increment global_id
                for event in range(input_data_n_events):
                    event_classification = output_data[event,0,2]
                    energy = output_data[event,0,0]
# Keep track of total number of escape and all_in events
                    if(event_classification==1):
                        self.total_escape += 1
                        self.avg_energy_escape += energy
                        self.weight_map.append(1)
                    elif (event_classification==0):
                        self.total_all_in += 1
                        self.avg_energy_all_in += energy
                        self.weight_map.append(0)
                    else:
                        raise Exception("Unknown escape class")
                    self.index_mapping[global_index] = (fpath, event)
                    global_index += 1
# Global_index at this point equals the the total number of events across all the .safetensor files in the directory
        if(self.total_all_in==0 or self.total_escape==0 or len(self.weight_map)==0):
            raise Exception("Couldn't generate weight map since either no all in events or no escape events")
        self.weight_map = [1.0/self.total_escape if (event_type==1) else 1.0/self.total_all_in for event_type in self.weight_map]
        self.avg_energy_all_in = self.avg_energy_all_in/self.total_all_in
        self.avg_energy_escape = self.avg_energy_escape/self.total_escape
        self.total_images = global_index
    def __len__(self):
        return self.total_images
    def __getitem__(self,index):
# the result of this function is a tuple, where the first value is the image of the anode plane, and the second value is the truth level output variables
# The output variables are, from left to right (as of Feb 8 2024): incident energy of gamma ray, first scattering angle, and an escape flag
# (1 for photon escaped, 0 for last scatter was a photoabsorption)
        if(index >= self.total_images):
            raise Exception("Index larger than number of images")
# Grab the relavent attributes needed to lazy load the tensor
        target_path, target_event = self.index_mapping[index]
        input_data = None
        output_data = None
# Extract the tensor(s), then return
        with safe_open(target_path, framework="pt") as f:
            input_data = f.get_tensor(self.input_name)[target_event,:,:]
            output_data = f.get_tensor(self.output_name)[target_event,:,:]
        if self.transform:
            input_data = self.transform(input_data)
        return (input_data, output_data)
# Get the weight mapping of the recorded events, total_all_in, total_escape, average energy of all in, and average energy of escape
    def emit_weight_map_data(self):
        return (self.weight_map, self.total_all_in, self.total_escape, self.avg_energy_all_in, self.avg_energy_escape)
    def plot(self,index):
# Utility function to plot an input anode plane image
        data = self.__getitem__(index)
        plt.pcolormesh(data[0])
        plt.colorbar()
# Use output tensor to title image
        TotalE = data[1][0,0].item()
        RecordedE = sum(sum(data[0])).item()
        title = "Init. E: "+str(round(TotalE,3))+" Rec. E: "+str(round(RecordedE,3))
        plt.title(title)
        plt.show()

def truth_level_class_pics(anodeDataset,verbose = False, plot=True, display_escape = True):
# Aggregate all events into a single image, sorted by class (one for "All In", on for "Escape"
    total = len(anodeDataset)
    xDim = anodeDataset[0][0].shape[1]
    yDim = anodeDataset[0][0].shape[2]
    AllIn = torch.zeros((xDim,yDim))
    Escape = torch.zeros((xDim,yDim))
    for i in range(total):
        if verbose:
            if(i%1000 ==0):
                print(i,total)
        inpt, output = anodeDataset[i]
        if int(output[0,2]) == 0:
            AllIn += inpt[0,:,:]
        else:
            Escape += inpt[0,:,:]
    if display_escape:
        plt.pcolormesh(Escape)
        plt.title("Agg. energy deps (Escape)")
    else:
        plt.pcolormesh(AllIn)
        plt.title("Agg. energy deps (AllIN)")
    plt.colorbar()
    plt.xlabel("X Pixel")
    plt.ylabel("Y Pixel")
    if(plot):
        plt.show()
    plt.savefig("test.png")
    return (AllIn, Escape)

if __name__ == "__main__":
    ad = AnodePlaneDataset("/nevis/milne/files/ms6556/BleekerData/GramsMLRecoData/Validation/",max_files=2)
#    truth_level_class_pics(ad,True, True, False)
